// Generated by dts-bundle-generator v9.5.1

import React$1 from 'react';

// Generated by dts-bundle-generator v9.5.1
/**
 * Type of generic subject guard
 */
export type SubjectGuard<TSubject extends object | null | undefined, TSubjectGuarded extends object | null | undefined> = (subject: TSubject) => {
	subject: TSubjectGuarded;
} | null | undefined;
/**
 * Permission granted with refined subject included.
 */
export type PermissionGrant<TSubjectOut> = {
	granted: true;
	subject: TSubjectOut;
};
/**
 * Permission denied, no refined subject required.
 */
export type PermissionDeny = {
	granted: false;
	message?: string;
};
/**
 * Permission is either granted (with refined subject) or denied based on the discriminated
 * union by the `granted: boolean` key.
 */
export type Permission<TSubjectOut> = PermissionGrant<TSubjectOut> | PermissionDeny;
/**
 * Object with string keys to type T with any depth.
 */
export type DeepObject<T> = {
	[key: string]: T | DeepObject<T>;
};
/**
 * Extracts all keys from an object which have a value of type Target.
 */
export type RecursiveKeysTo<Object, Target, Separator extends string = "."> = Object extends object ? {
	[Key in keyof Object]: Key extends string | number ? Object[Key] extends Target ? Key : `${Key}${Separator}${RecursiveKeysTo<Object[Key], Target, Separator>}` : never;
}[keyof Object] : never;
/**
 * Extracts all values from an object which have a key of type Target.
 */
export type RecursiveValueByKey<Object, Key extends string, Separator extends string = "."> = Object extends object ? Key extends `${infer FirstKey}${Separator}${infer Rest}` ? FirstKey extends keyof Object ? RecursiveValueByKey<Object[FirstKey], Rest, Separator> : never : Key extends keyof Object ? Object[Key] : never : never;
/**
 * Value optionally wrapped in a promise.
 */
export type MaybePromise<T> = T | Promise<T>;
/**
 * A rule is a function that receives a subject and a resource and returns a permission with a
 * potentially narrowed subject.
 *
 * Additionally, the subject guard function is attached.
 */
export type Rule<TResource, TSubject extends object | null | undefined, TGuardedSubject extends object | null | undefined = TSubject> = ((subject: TSubject, resource: TResource) => Promise<Permission<TGuardedSubject>>) & {
	/**
	 * Subject guard
	 */
	guard: SubjectGuard<TSubject, TGuardedSubject>;
};
/**
 * Rule inferral utilities
 */
export type InferRule<T> = T extends Rule<infer TResource, infer TSubject, infer TGuardedSubject> ? {
	resource: TResource;
	subject: TSubject;
	guardedSubject: TGuardedSubject;
} : never;
export type InferRuleResource<T> = InferRule<T>["resource"];
export type InferRuleGuardedSubject<T> = InferRule<T>["guardedSubject"];
declare const RULE_KEY_SEPARATOR: ":";
/**
 * Rule-set is a deep-object of rules which all share a common base subject type.
 */
export type Ruleset<TSubject extends object | null | undefined> = DeepObject<Rule<any, TSubject, any>>;
/**
 * List of all keys in ruleset.
 */
export type RulesetKeys<TRuleset extends Ruleset<any>> = RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject> ? Rule<any, TSubject, any> : never, typeof RULE_KEY_SEPARATOR>;
/**
 * Ensure a value is a rule
 */
export type EnsureTypeIsRule<T> = T extends Rule<any, any, any> ? T : never;
/**
 * Type of a rule from a ruleset given a key.
 */
export type GetRuleByKey<TRuleset extends Ruleset<any>, TKey extends RulesetKeys<TRuleset>> = EnsureTypeIsRule<RecursiveValueByKey<TRuleset, TKey, typeof RULE_KEY_SEPARATOR>>;
export type KilpiConstructor<TSubject extends object | null | undefined> = {
	/**
	 * Create subject guard
	 */
	guard: <TGuardedSubject extends object | null | undefined>(guard: SubjectGuard<TSubject, TGuardedSubject>) => SubjectGuard<TSubject, TGuardedSubject> & {
		/**
		 * Create rule wth guard
		 */
		create: <TResource>(check: (subject: TGuardedSubject, resource: TResource) => MaybePromise<boolean | Permission<TGuardedSubject>>) => Rule<TResource | TResource[], TSubject, TGuardedSubject>;
	};
	/**
	 * Create Rule without guard (equal to creating with trivial guard)
	 */
	create: <TResource>(check: (subject: TSubject, resource: TResource) => MaybePromise<boolean | Permission<TSubject>>) => Rule<TResource | TResource[], TSubject, TSubject>;
};
/**
 * Handler when `protect()` denies access. Either a sync or async function that runs a side effect
 * on denial (e.g. a log) or throws an error or other throwable, e.g. a redirect.
 */
export type OnDenyHandler = (options: {
	message?: string;
	rule: Rule<any, any, any>;
	subject: unknown;
}) => void | never | Promise<void> | Promise<never>;
declare class KilpiCore<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TGuards extends Record<string, SubjectGuard<TSubject, object | null | undefined>>> {
	/**
	 * Subject fetcher
	 */
	getSubject: () => TSubject | Promise<TSubject>;
	/**
	 * Ruleset from construction
	 */
	ruleset: TRuleset;
	/**
	 * All subject guard functions from construction
	 */
	guards: TGuards;
	/**
	 * Inferring utilities. Do not use in runtime.
	 */
	$$infer: {
		subject: TSubject;
		ruleset: TRuleset;
		guards: TGuards;
	};
	/**
	 * New instance
	 */
	constructor(getSubject: () => TSubject | Promise<TSubject>, construct: (constructor: KilpiConstructor<TSubject>) => {
		guards: TGuards;
		rules: TRuleset;
	});
	/**
	 * Get permission to a rule inside the ruleset
	 */
	getPermission<TKey extends RulesetKeys<TRuleset>>(key: TKey, resource: InferRuleResource<GetRuleByKey<TRuleset, TKey>>): Promise<Permission<InferRuleGuardedSubject<GetRuleByKey<TRuleset, TKey>>>>;
	/**
	 * Get permission to a rule inside the ruleset (only return boolean)
	 */
	hasPermission<TKey extends RulesetKeys<TRuleset>>(key: TKey, resource: InferRuleResource<GetRuleByKey<TRuleset, TKey>>): Promise<boolean>;
	/**
	 * Throw if no permission, else return guarded subject
	 */
	protect<TKey extends RulesetKeys<TRuleset>>(key: TKey, resource: InferRuleResource<GetRuleByKey<TRuleset, TKey>>, onDeny?: OnDenyHandler): Promise<InferRuleGuardedSubject<GetRuleByKey<TRuleset, TKey>>>;
	/**
	 * Expose guards via `guard.[guardKey]` syntax, similar to protect but without requiring a
	 * resource. E.g., `await KilpiCore.guard.authed()`.
	 */
	get guard(): TGuards;
	/**
	 * Create protected query
	 */
	createProtectedQuery<TQuery extends (...args: any[]) => Promise<any>>(query: TQuery, protector?: (result: Awaited<ReturnType<TQuery>>, ...args: Parameters<TQuery>) => Promise<any>): TQuery & {
		/**
		 * Return null if the authorization check fails
		 */
		safe(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>> | null>;
		/**
		 * Throw if authorization check fails
		 */
		protect(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>>>;
	};
	/**
	 * Create endpoint handler
	 */
	createPostEndpoint(options: {
		secret: string;
	}): (request: Request) => Promise<Response>;
}
export type SubjectGuard$1<TSubject extends object | null | undefined, TSubjectGuarded extends object | null | undefined> = (subject: TSubject) => {
	subject: TSubjectGuarded;
} | null | undefined;
export type PermissionGrant$1<TSubjectOut> = {
	granted: true;
	subject: TSubjectOut;
};
export type PermissionDeny$1 = {
	granted: false;
	message?: string;
};
export type Permission$1<TSubjectOut> = PermissionGrant$1<TSubjectOut> | PermissionDeny$1;
export type DeepObject$1<T> = {
	[key: string]: T | DeepObject$1<T>;
};
export type RecursiveKeysTo$1<Object, Target, Separator extends string = "."> = Object extends object ? {
	[Key in keyof Object]: Key extends string | number ? Object[Key] extends Target ? Key : `${Key}${Separator}${RecursiveKeysTo$1<Object[Key], Target, Separator>}` : never;
}[keyof Object] : never;
export type RecursiveValueByKey$1<Object, Key extends string, Separator extends string = "."> = Object extends object ? Key extends `${infer FirstKey}${Separator}${infer Rest}` ? FirstKey extends keyof Object ? RecursiveValueByKey$1<Object[FirstKey], Rest, Separator> : never : Key extends keyof Object ? Object[Key] : never : never;
export type MaybePromise$1<T> = T | Promise<T>;
export type Rule$1<TResource, TSubject extends object | null | undefined, TGuardedSubject extends object | null | undefined = TSubject> = ((subject: TSubject, resource: TResource) => Promise<Permission$1<TGuardedSubject>>) & {
	/**
	 * Subject guard
	 */
	guard: SubjectGuard$1<TSubject, TGuardedSubject>;
};
export type InferRule$1<T> = T extends Rule$1<infer TResource, infer TSubject, infer TGuardedSubject> ? {
	resource: TResource;
	subject: TSubject;
	guardedSubject: TGuardedSubject;
} : never;
export type InferRuleResource$1<T> = InferRule$1<T>["resource"];
export type InferRuleGuardedSubject$1<T> = InferRule$1<T>["guardedSubject"];
declare const RULE_KEY_SEPARATOR$1: ":";
export type Ruleset$1<TSubject extends object | null | undefined> = DeepObject$1<Rule$1<any, TSubject, any>>;
export type RulesetKeys$1<TRuleset extends Ruleset$1<any>> = RecursiveKeysTo$1<TRuleset, TRuleset extends Ruleset$1<infer TSubject> ? Rule$1<any, TSubject, any> : never, typeof RULE_KEY_SEPARATOR$1>;
export type EnsureTypeIsRule$1<T> = T extends Rule$1<any, any, any> ? T : never;
export type GetRuleByKey$1<TRuleset extends Ruleset$1<any>, TKey extends RulesetKeys$1<TRuleset>> = EnsureTypeIsRule$1<RecursiveValueByKey$1<TRuleset, TKey, typeof RULE_KEY_SEPARATOR$1>>;
export type KilpiConstructor$1<TSubject extends object | null | undefined> = {
	/**
	 * Create subject guard
	 */
	guard: <TGuardedSubject extends object | null | undefined>(guard: SubjectGuard$1<TSubject, TGuardedSubject>) => SubjectGuard$1<TSubject, TGuardedSubject> & {
		/**
		 * Create rule wth guard
		 */
		create: <TResource>(check: (subject: TGuardedSubject, resource: TResource) => MaybePromise$1<boolean | Permission$1<TGuardedSubject>>) => Rule$1<TResource | TResource[], TSubject, TGuardedSubject>;
	};
	/**
	 * Create Rule without guard (equal to creating with trivial guard)
	 */
	create: <TResource>(check: (subject: TSubject, resource: TResource) => MaybePromise$1<boolean | Permission$1<TSubject>>) => Rule$1<TResource | TResource[], TSubject, TSubject>;
};
export type OnDenyHandler$1 = (options: {
	message?: string;
	rule: Rule$1<any, any, any>;
	subject: unknown;
}) => void | never | Promise<void> | Promise<never>;
declare class KilpiCore$1<TSubject extends object | null | undefined, TRuleset extends Ruleset$1<TSubject>, TGuards extends Record<string, SubjectGuard$1<TSubject, object | null | undefined>>> {
	/**
	 * Subject fetcher
	 */
	getSubject: () => TSubject | Promise<TSubject>;
	/**
	 * Ruleset from construction
	 */
	ruleset: TRuleset;
	/**
	 * All subject guard functions from construction
	 */
	guards: TGuards;
	/**
	 * Inferring utilities. Do not use in runtime.
	 */
	$$infer: {
		subject: TSubject;
		ruleset: TRuleset;
		guards: TGuards;
	};
	/**
	 * New instance
	 */
	constructor(getSubject: () => TSubject | Promise<TSubject>, construct: (constructor: KilpiConstructor$1<TSubject>) => {
		guards: TGuards;
		rules: TRuleset;
	});
	/**
	 * Get permission to a rule inside the ruleset
	 */
	getPermission<TKey extends RulesetKeys$1<TRuleset>>(key: TKey, resource: InferRuleResource$1<GetRuleByKey$1<TRuleset, TKey>>): Promise<Permission$1<InferRuleGuardedSubject$1<GetRuleByKey$1<TRuleset, TKey>>>>;
	/**
	 * Get permission to a rule inside the ruleset (only return boolean)
	 */
	hasPermission<TKey extends RulesetKeys$1<TRuleset>>(key: TKey, resource: InferRuleResource$1<GetRuleByKey$1<TRuleset, TKey>>): Promise<boolean>;
	/**
	 * Throw if no permission, else return guarded subject
	 */
	protect<TKey extends RulesetKeys$1<TRuleset>>(key: TKey, resource: InferRuleResource$1<GetRuleByKey$1<TRuleset, TKey>>, onDeny?: OnDenyHandler$1): Promise<InferRuleGuardedSubject$1<GetRuleByKey$1<TRuleset, TKey>>>;
	/**
	 * Expose guards via `guard.[guardKey]` syntax, similar to protect but without requiring a
	 * resource. E.g., `await KilpiCore.guard.authed()`.
	 */
	get guard(): TGuards;
	/**
	 * Create protected query
	 */
	createProtectedQuery<TQuery extends (...args: any[]) => Promise<any>>(query: TQuery, protector?: (result: Awaited<ReturnType<TQuery>>, ...args: Parameters<TQuery>) => Promise<any>): TQuery & {
		/**
		 * Return null if the authorization check fails
		 */
		safe(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>> | null>;
		/**
		 * Throw if authorization check fails
		 */
		protect(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>>>;
	};
	/**
	 * Create endpoint handler
	 */
	createPostEndpoint(options: {
		secret: string;
	}): (request: Request) => Promise<Response>;
}
/**
 * Storage for a value that can be read and written.
 */
export type GetSetStorage<T> = {
	get: () => T;
	set: (value: T) => void;
};
/**
 * Server client construction options
 */
export type CreateKilpiServerClientOptions = {
	/**
	 * Customize `.protect()` behaviour by providing a global `.onDeny` function. You can also provide
	 * a storage with get and set methods. Using a per-request storage is recommended.
	 */
	onDeny?: OnDenyHandler$1 | GetSetStorage<OnDenyHandler$1 | undefined>;
};
/**
 * Type of server client
 */
export type KilpiServerClient<TCore extends KilpiCore$1<any, any, any>> = ReturnType<typeof createKilpiServerClient<TCore>>;
declare function createKilpiServerClient<TCore extends KilpiCore$1<any, any, any>>(core: TCore, options: CreateKilpiServerClientOptions): {
	guard: any;
	getSubject: () => any;
	getPermission: <TKey extends string>(key: TKey, resource: InferRuleResource$1<EnsureTypeIsRule$1<TKey extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey extends string | number | symbol ? any : never>>) => Promise<Permission$1<InferRuleGuardedSubject$1<EnsureTypeIsRule$1<TKey extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey extends string | number | symbol ? any : never>>>>;
	hasPermission: <TKey_1 extends string>(key: TKey_1, resource: InferRuleResource$1<EnsureTypeIsRule$1<TKey_1 extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey_1 extends string | number | symbol ? any : never>>) => Promise<boolean>;
	protect: <TKey_2 extends string>(key: TKey_2, resource: InferRuleResource$1<EnsureTypeIsRule$1<TKey_2 extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey_2 extends string | number | symbol ? any : never>>, onDeny?: OnDenyHandler$1 | undefined) => Promise<InferRuleGuardedSubject$1<EnsureTypeIsRule$1<TKey_2 extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey_2 extends string | number | symbol ? any : never>>>;
	createProtectedQuery: <TQuery extends (...args: any[]) => Promise<any>>(query: TQuery, protector?: ((result: Awaited<ReturnType<TQuery>>, ...args: Parameters<TQuery>) => Promise<any>) | undefined) => TQuery & {
		safe(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>> | null>;
		protect(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>>>;
	};
	createPostEndpoint: (options: {
		secret: string;
	}) => (request: Request) => Promise<Response>;
	onDeny: (onDenyHandler: OnDenyHandler$1 | undefined) => void;
	core: TCore;
};
/**
 * Client-side client construction options
 */
export type CreateKilpiClientSideClientOptions = {
	secret: string;
	endpoint: string;
};
/**
 * Type of client-side client
 */
export type KilpiClientSideClient<TKilpiServerClient extends KilpiServerClient<KilpiCore<any, any, any>>> = ReturnType<typeof createKilpiClientSideClient<TKilpiServerClient>>;
export type AnyKilpiClientSideClient = KilpiClientSideClient<KilpiServerClient<KilpiCore<any, any, any>>>;
declare function createKilpiClientSideClient<TKilpiServerClient extends KilpiServerClient<KilpiCore<any, any, any>>>(options: CreateKilpiClientSideClientOptions): {
	getSubject: () => Promise<Awaited<ReturnType<TKilpiServerClient["core"]["getSubject"]>>>;
	getPermission: <TKey extends RulesetKeys<TKilpiServerClient["core"]["ruleset"]>>(key: TKey, resource: InferRuleResource<GetRuleByKey<TKilpiServerClient["core"]["ruleset"], TKey>>) => Promise<Permission<InferRuleGuardedSubject<GetRuleByKey<TKilpiServerClient["core"]["ruleset"], TKey>>>>;
	invalidate: void;
	onInvalidate: (callback: () => void) => void;
	$$infer: TKilpiServerClient["core"]["$$infer"];
};
export type CreateReactClientSideComponentOptions = {
	DefaultErrorComponent?: React$1.ReactNode;
	DefaultDeniedComponent?: React$1.ReactNode;
	DefaultLoadingComponent?: React$1.ReactNode;
};
export type UseSubjectReturn<TClient extends AnyKilpiClientSideClient> = {
	status: "loading";
} | {
	status: "error";
} | {
	status: "success";
	subject: TClient["$$infer"]["subject"];
};
export type UsePermissionReturn<TClient extends AnyKilpiClientSideClient, TKey extends RulesetKeys<TClient["$$infer"]["ruleset"]>> = {
	status: "loading";
} | {
	status: "denied";
	message?: string;
} | {
	status: "error";
} | {
	status: "granted";
	subject: InferRuleGuardedSubject<GetRuleByKey<TClient["$$infer"]["ruleset"], TKey>>;
};
/**
 * Has permission props
 */
export type WithPermissionProps<TClient extends AnyKilpiClientSideClient, TKey extends RulesetKeys<TClient["$$infer"]["ruleset"]>> = {
	/**
	 * Rule key to access.
	 */
	key: TKey;
	/**
	 * Resource to provide to rule. Pass undefined / null if no resource is needed.
	 */
	resource: InferRuleResource<GetRuleByKey<TClient["$$infer"]["ruleset"], TKey>>;
	/**
	 * Render based on dynamic render prop function with access as argument.
	 */
	children?: (permission: UsePermissionReturn<TClient, TKey>) => React$1.ReactNode;
};
/**
 * Has permission props
 */
export type HasPermissionProps<TClient extends AnyKilpiClientSideClient, TKey extends RulesetKeys<TClient["$$infer"]["ruleset"]>> = {
	/**
	 * Rule key to access.
	 */
	key: TKey;
	/**
	 * Resource to provide to rule. Pass undefined / null if no resource is needed.
	 */
	resource: InferRuleResource<GetRuleByKey<TClient["$$infer"]["ruleset"], TKey>>;
	/**
	 * Rendered when access is granted.
	 */
	children?: React$1.ReactNode;
	/**
	 * Rendered while fetching. If undefined, defaults to global default if exists.
	 * If null, no loading component is rendered.
	 */
	Loading?: React$1.ReactNode;
	/**
	 * Rendered if access is denied. If undefined, defaults to global default if exists.
	 * If null, no denied component is rendered.
	 */
	Denied?: React$1.ReactNode;
	/**
	 * Rendered if fetch errored. If undefined, defaults to global default if exists.
	 * If null, no denied component is rendered.
	 */
	Error?: React$1.ReactNode;
};
/**
 * Create all React client components for Kilpi usage on React in browser or SSR.
 */
export declare function createKilpiReactClientComponents<TClient extends AnyKilpiClientSideClient>(KilpiClient: TClient, options: CreateReactClientSideComponentOptions): {
	WithPermission: <TClient_1 extends AnyKilpiClientSideClient, TKey extends RulesetKeys<TClient_1["$$infer"]["ruleset"]>>(props: WithPermissionProps<TClient_1, TKey>) => React$1.ReactNode;
	HasPermission: <TClient_2 extends AnyKilpiClientSideClient, TKey_1 extends RulesetKeys<TClient_2["$$infer"]["ruleset"]>>(props: HasPermissionProps<TClient_2, TKey_1>) => React$1.ReactNode;
	useSubject: <TClient_3 extends AnyKilpiClientSideClient>({ KilpiClient, }: {
		KilpiClient: TClient_3;
	}) => UseSubjectReturn<TClient_3>;
	usePermission: <TClient_4 extends AnyKilpiClientSideClient, TKey_2 extends RulesetKeys<TClient_4["$$infer"]["ruleset"]>>(key: TKey_2, resource: InferRuleResource<GetRuleByKey<TClient_4["$$infer"]["ruleset"], TKey_2>>) => UsePermissionReturn<TClient_4, TKey_2>;
	useInvalidationSignal: <TClient_5 extends AnyKilpiClientSideClient>(KilpiClient: TClient_5) => number;
};

export {};
