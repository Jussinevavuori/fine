// Generated by dts-bundle-generator v9.5.1

import { z } from 'zod';

/**
 * Permission granted with refined subject included.
 */
export type PermissionGrant<TSubjectOut> = {
	granted: true;
	subject: TSubjectOut;
};
/**
 * Permission denied, no refined subject required.
 */
export type PermissionDeny = {
	granted: false;
	message?: string;
};
/**
 * Permission is either granted (with refined subject) or denied based on the discriminated
 * union by the `granted: boolean` key.
 */
export type Permission<TSubjectOut> = PermissionGrant<TSubjectOut> | PermissionDeny;
declare function Grant<TSubjectOut>(subject: TSubjectOut): PermissionGrant<TSubjectOut>;
declare function Deny(message?: string): PermissionDeny;
declare const Permission: {
	Grant: typeof Grant;
	Deny: typeof Deny;
};
/**
 * A rule consists of the `getPermission` evaluator function, which when given the subject and
 * resource returns the permission to that resource. Additionally, it consists of the
 * `getNarrowedSubject` function which narrows the subject to a more specific type before
 * evaluation.
 */
export type Rule<TResource, TSubject, TSubjectNarrowed = TSubject> = {
	/**
	 * Based on subject and resource, return a permission. Runs subject narrowing within.
	 */
	getPermission: (subject: TSubject, resource: TResource) => Promise<Permission<TSubjectNarrowed>>;
	/**
	 * Returning false signals a denied permission. Subject-narrowing does not depend on the resource.
	 */
	getNarrowedSubject: (subject: TSubject) => TSubjectNarrowed | false;
};
/**
 * Rule inferral utilities
 */
export type InferRule<T> = T extends Rule<infer TResource, infer TSubject, infer TSubjectNarrowed> ? {
	resource: TResource;
	subject: TSubject;
	subjectNarrowed: TSubjectNarrowed;
} : never;
export type InferRuleResource<T> = InferRule<T>["resource"];
export type InferRuleSubject<T> = InferRule<T>["subject"];
export type InferRuleSubjectNarrowed<T> = InferRule<T>["subjectNarrowed"];
/**
 * Compare two types for equality.
 */
export type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? true : false;
/**
 * Object with string keys to type T with any depth.
 */
export type DeepObject<T> = {
	[key: string]: T | DeepObject<T>;
};
/**
 * Extracts all keys from an object which have a value of type Target.
 */
export type RecursiveKeysTo<Object, Target, Separator extends string = "."> = Object extends object ? {
	[Key in keyof Object]: Key extends string | number ? Object[Key] extends Target ? Key : `${Key}${Separator}${RecursiveKeysTo<Object[Key], Target, Separator>}` : never;
}[keyof Object] : never;
/**
 * Extracts all values from an object which have a key of type Target.
 */
export type RecursiveValueByKey<Object, Key extends string, Separator extends string = "."> = Object extends object ? Key extends `${infer FirstKey}${Separator}${infer Rest}` ? FirstKey extends keyof Object ? RecursiveValueByKey<Object[FirstKey], Rest, Separator> : never : Key extends keyof Object ? Object[Key] : never : never;
/**
 * Value optionally wrapped in a promise.
 */
export type MaybePromise<T> = T | Promise<T>;
/**
 * Separator for rule keys.
 */
export declare const RULE_KEY_SEPARATOR: ":";
/**
 * Rule-set is a deep-object of rules which all share a common base subject type.
 */
export type Ruleset<TSubject> = DeepObject<Rule<any, TSubject, any>>;
/**
 * List of all keys in ruleset.
 */
export type RulesetKeys<TRuleset extends Ruleset<any>> = RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject> ? Rule<any, TSubject> : never, typeof RULE_KEY_SEPARATOR>;
/**
 * Key => Resource of a rule map
 */
export type RulesetResourceMap<TRuleset extends Ruleset<any>> = {
	[Key in RulesetKeys<TRuleset>]: InferRuleResource<GetRuleByKey<TRuleset, Key>>;
};
/**
 * List of all keys in ruleset that require a resource.
 */
export type RulesetKeysWithResource<TRuleset extends Ruleset<any>> = keyof {
	[Key in RulesetKeys<TRuleset>]: Equals<InferRuleResource<GetRuleByKey<TRuleset, Key>>, any> extends true ? never : true;
};
/**
 * List of all keys in ruleset that do not require a resource.
 */
export type RulesetKeysWithoutResource<TRuleset extends Ruleset<any>> = keyof {
	[Key in RulesetKeys<TRuleset>]: Equals<InferRuleResource<GetRuleByKey<TRuleset, Key>>, any> extends true ? true : never;
};
/**
 * Ensure a value is a rule
 */
export type EnsureTypeIsRule<T> = T extends Rule<any, any, any> ? T : never;
/**
 * Type of a rule from a ruleset given a key.
 */
export type GetRuleByKey<TRuleset extends Ruleset<any>, TKey extends RulesetKeys<TRuleset>> = EnsureTypeIsRule<RecursiveValueByKey<TRuleset, TKey, typeof RULE_KEY_SEPARATOR>>;
/**
 * Get a rule from a ruleset given a key.
 */
export declare function getRuleByKey<const TRuleset extends Ruleset<any>, TKey extends RulesetKeys<TRuleset>>(ruleset: TRuleset, key: TKey): GetRuleByKey<TRuleset, TKey>;
declare const requestSchema: z.ZodDiscriminatedUnion<"action", [
	z.ZodObject<{
		action: z.ZodLiteral<"fetchSubject">;
	}, "strip", z.ZodTypeAny, {
		action: "fetchSubject";
	}, {
		action: "fetchSubject";
	}>,
	z.ZodObject<{
		action: z.ZodLiteral<"fetchPermissions">;
		rules: z.ZodArray<z.ZodObject<{
			key: z.ZodString;
			resource: z.ZodOptional<z.ZodAny>;
		}, "strip", z.ZodTypeAny, {
			key: string;
			resource?: any;
		}, {
			key: string;
			resource?: any;
		}>, "many">;
	}, "strip", z.ZodTypeAny, {
		action: "fetchPermissions";
		rules: {
			key: string;
			resource?: any;
		}[];
	}, {
		action: "fetchPermissions";
		rules: {
			key: string;
			resource?: any;
		}[];
	}>
]>;
export type KilpiEndpointRequestBody = z.infer<typeof requestSchema>;
export type KilpiEndpointRequestAction = KilpiEndpointRequestBody["action"];
export type CreatePostEndpointOptions<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>> = {
	subject: TSubject | (() => Promise<TSubject>);
	ruleset: TRuleset;
	secret: string;
};
/**
 * Create post endpoint with the given options.
 */
export declare function createPostEndpoint<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>>(options: CreatePostEndpointOptions<TSubject, TRuleset>): (request: Request) => Promise<Response>;
export type CreateQueryOptions<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TQuery extends (...args: any[]) => any> = {
	subject: TSubject | (() => Promise<TSubject>);
	ruleset: TRuleset;
	query: TQuery;
	protector?: (result: Awaited<ReturnType<TQuery>>, ...args: Parameters<TQuery>) => any;
};
/**
 * Create a query by providing a `protector` function which is used to protect the query when it
 * is called with the now attached `.safe` and `.protect` methods.
 */
export declare function createQuery<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TQuery extends (...args: any[]) => any>(options: CreateQueryOptions<TSubject, TRuleset, TQuery>): TQuery & {
	/**
	 * Return null if the authorization check fails
	 *
	 * TODO: Automatic filtering of arrays?
	 */
	safe(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>> | null>;
	/**
	 * Fail if authorization check fails
	 */
	protect(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>>>;
};
/**
 * Initialize rule constructors for a certain subject type. This provides the `.create()`
 * and  `.subject(...).create()` utility methods for constructing rules.
 *
 * ```
 * const Rule = initializeRules<MySubject>();
 *
 * const AuthedRule = Rule.subject((subject) => subject.authed ? subject : false);
 *
 * const ruleset = {
 *   document: {
 *     count: Rule.create(() => true), // Public
 *     read: AuthedRule.createOn<Document>((subject, resource) => subject.id === resource.authorId), // Authed
 *     create: AuthedRule.create(() => true), // Authed
 *   }
 * }
 * ```
 *
 * TODO: Simplify current 4x implementation
 */
export declare function getRuleConstructors<TSubject extends object | null | undefined, TNarrowedSubject extends object | null | undefined = TSubject>(): {
	create: (check: (subject: TSubject) => MaybePromise<boolean | Permission<TSubject>>) => Rule<void, TSubject>;
	createOn: <TResource>(check: (subject: TSubject, resource: TResource) => MaybePromise<boolean | Permission<TSubject>>) => Rule<TResource | TResource[], TSubject>;
	subject: <TSubjectNarrowed>(getNarrowedSubject: (subject: TSubject) => false | TSubjectNarrowed) => {
		create(check: (subject: TSubjectNarrowed) => MaybePromise<boolean | Permission<TSubjectNarrowed>>): Rule<void, TSubject, TSubjectNarrowed>;
		/**
		 * Create a rule after subject narrowing for a specific resource.
		 */
		createOn<TResource_1>(check: (subject: TSubjectNarrowed, resource: TResource_1) => MaybePromise<boolean | Permission<TSubjectNarrowed>>): Rule<TResource_1 | TResource_1[], TSubject, TSubjectNarrowed>;
	};
};
export type RuleConstructors<TSubject extends object | null | undefined> = ReturnType<typeof getRuleConstructors<TSubject>>;
/**
 * Create ruleset separately. Requires calling with subject first before creating rules due to
 * TypeScript limitations.
 *
 * `createRuleset<MySubject>()(Rule => {
 *   return {
 *     ...
 *   }
 * })`
 */
export declare function createRuleset<TSubject extends object | null | undefined>(): <const TRuleset extends Ruleset<TSubject>>(rules: (Rule: RuleConstructors<TSubject>) => TRuleset) => TRuleset;
declare class KilpiInternalError extends Error {
	constructor(message: string, options?: {
		cause?: unknown;
	});
}
declare class KilpiPermissionDeniedError extends Error {
	constructor(message: string);
}
declare class KilpiInvalidSetupError extends Error {
	constructor(message: string);
}
declare class KilpiFetchPermissionFailedError extends Error {
	constructor(message: string);
}
declare class KilpiFetchSubjectFailedError extends Error {
	constructor(message: string);
}
/**
 * All Kilpi errors.
 */
export declare const KilpiError: {
	Internal: typeof KilpiInternalError;
	InvalidSetup: typeof KilpiInvalidSetupError;
	PermissionDenied: typeof KilpiPermissionDeniedError;
	FetchSubjectFailed: typeof KilpiFetchSubjectFailedError;
	FetchPermissionFailed: typeof KilpiFetchPermissionFailedError;
};
/**
 * Get permission options. Resource is optionally added if the rule requires it in the overloads.
 */
export type GetPermissionOptions<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeysWithResource<TRuleset>> = {
	subject: TSubject | (() => Promise<TSubject>);
	ruleset: TRuleset;
	key: TRulekey;
};
/**
 * Return type of get permission.
 */
export type GetPermissionReturn<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeys<TRuleset>> = Promise<Permission<InferRuleSubjectNarrowed<GetRuleByKey<TRuleset, TRulekey>>>>;
/**
 * Get permission given a ruleset, subject, key, and optionally a resource based on the rule.
 * Returns a permission object with a `granted` proeprty and a narrowed subject if granted, else
 * a message.
 *
 * Has overloads for rules with and without resources.
 */
export declare function getPermission<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeysWithResource<TRuleset>>(options: GetPermissionOptions<TSubject, TRuleset, TRulekey> & {
	resource: InferRuleResource<GetRuleByKey<TRuleset, TRulekey>>;
}): GetPermissionReturn<TSubject, TRuleset, TRulekey>;
export declare function getPermission<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeysWithoutResource<TRuleset>>(options: GetPermissionOptions<TSubject, TRuleset, TRulekey>): GetPermissionReturn<TSubject, TRuleset, TRulekey>;
/**
 * Check if the given subject (over the given rule and on the given resource) has access. Only
 * returns a boolean. To receive the entire permission, use `getPermission` instead.
 */
export declare function hasPermission<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeysWithResource<TRuleset>>(options: GetPermissionOptions<TSubject, TRuleset, TRulekey> & {
	resource: InferRuleResource<GetRuleByKey<TRuleset, TRulekey>>;
}): Promise<boolean>;
export declare function hasPermission<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeysWithoutResource<TRuleset>>(options: GetPermissionOptions<TSubject, TRuleset, TRulekey>): Promise<boolean>;
/**
 * Handler when `protect()` denies access. Either a sync or async function that runs a side effect
 * on denial (e.g. a log) or throws an error or other throwable, e.g. a redirect.
 */
export type OnDenyHandler = (options: {
	message?: string;
	rule: Rule<any, any, any>;
	subject: unknown;
}) => void | never | Promise<void> | Promise<never>;
/**
 * Protect options. Resource is optionally added if the rule requires it in the overloads.
 */
export type ProtectOptions<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey> = {
	subject: TSubject | (() => Promise<TSubject>);
	ruleset: TRuleset;
	key: TRulekey;
	onDeny?: OnDenyHandler | (() => OnDenyHandler);
};
/**
 * Return type of protection (when succesful).
 */
export type ProtectReturn<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeys<TRuleset>> = Promise<InferRuleSubjectNarrowed<GetRuleByKey<TRuleset, TRulekey>>>;
/**
 * Protect function. Given a ruleset, subject, key, and optionally a resource, checks if the subject
 * passess the specified rule and is granted permission. If not, throws a PermissionDenied error
 * (or other throwable via `onDeny` function).
 *
 * Has overloads for rules with and without resources.
 */
export declare function protect<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeysWithResource<TRuleset>>(options: ProtectOptions<TSubject, TRuleset, TRulekey> & {
	resource: InferRuleResource<GetRuleByKey<TRuleset, TRulekey>>;
}): ProtectReturn<TSubject, TRuleset, TRulekey>;
export declare function protect<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeysWithoutResource<TRuleset>>(options: ProtectOptions<TSubject, TRuleset, TRulekey>): ProtectReturn<TSubject, TRuleset, TRulekey>;

export {};
