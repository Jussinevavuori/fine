// Generated by dts-bundle-generator v9.5.1

/**
 * Type of generic subject guard
 */
export type SubjectGuard<TSubject extends object | null | undefined, TSubjectGuarded extends object | null | undefined> = (subject: TSubject) => {
	subject: TSubjectGuarded;
} | null | undefined;
/**
 * Permission granted with refined subject included.
 */
export type PermissionGrant<TSubjectOut> = {
	granted: true;
	subject: TSubjectOut;
};
/**
 * Permission denied, no refined subject required.
 */
export type PermissionDeny = {
	granted: false;
	message?: string;
};
/**
 * Permission is either granted (with refined subject) or denied based on the discriminated
 * union by the `granted: boolean` key.
 */
export type Permission<TSubjectOut> = PermissionGrant<TSubjectOut> | PermissionDeny;
declare function Grant<TSubjectOut>(subject: TSubjectOut): PermissionGrant<TSubjectOut>;
declare function Deny(message?: string): PermissionDeny;
declare const Permission: {
	Grant: typeof Grant;
	Deny: typeof Deny;
};
/**
 * Object with string keys to type T with any depth.
 */
export type DeepObject<T> = {
	[key: string]: T | DeepObject<T>;
};
/**
 * Extracts all keys from an object which have a value of type Target.
 */
export type RecursiveKeysTo<Object, Target, Separator extends string = "."> = Object extends object ? {
	[Key in keyof Object]: Key extends string | number ? Object[Key] extends Target ? Key : `${Key}${Separator}${RecursiveKeysTo<Object[Key], Target, Separator>}` : never;
}[keyof Object] : never;
/**
 * Extracts all values from an object which have a key of type Target.
 */
export type RecursiveValueByKey<Object, Key extends string, Separator extends string = "."> = Object extends object ? Key extends `${infer FirstKey}${Separator}${infer Rest}` ? FirstKey extends keyof Object ? RecursiveValueByKey<Object[FirstKey], Rest, Separator> : never : Key extends keyof Object ? Object[Key] : never : never;
/**
 * Value optionally wrapped in a promise.
 */
export type MaybePromise<T> = T | Promise<T>;
/**
 * A rule is a function that receives a subject and a resource and returns a permission with a
 * potentially narrowed subject.
 *
 * Additionally, the subject guard function is attached.
 */
export type Rule<TResource, TSubject extends object | null | undefined, TGuardedSubject extends object | null | undefined = TSubject> = ((subject: TSubject, resource: TResource) => Promise<Permission<TGuardedSubject>>) & {
	/**
	 * Subject guard
	 */
	guard: SubjectGuard<TSubject, TGuardedSubject>;
};
/**
 * Rule inferral utilities
 */
export type InferRule<T> = T extends Rule<infer TResource, infer TSubject, infer TGuardedSubject> ? {
	resource: TResource;
	subject: TSubject;
	guardedSubject: TGuardedSubject;
} : never;
export type InferRuleResource<T> = InferRule<T>["resource"];
export type InferRuleGuardedSubject<T> = InferRule<T>["guardedSubject"];
declare const RULE_KEY_SEPARATOR: ":";
/**
 * Rule-set is a deep-object of rules which all share a common base subject type.
 */
export type Ruleset<TSubject extends object | null | undefined> = DeepObject<Rule<any, TSubject, any>>;
/**
 * List of all keys in ruleset.
 */
export type RulesetKeys<TRuleset extends Ruleset<any>> = RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject> ? Rule<any, TSubject, any> : never, typeof RULE_KEY_SEPARATOR>;
/**
 * Ensure a value is a rule
 */
export type EnsureTypeIsRule<T> = T extends Rule<any, any, any> ? T : never;
/**
 * Type of a rule from a ruleset given a key.
 */
export type GetRuleByKey<TRuleset extends Ruleset<any>, TKey extends RulesetKeys<TRuleset>> = EnsureTypeIsRule<RecursiveValueByKey<TRuleset, TKey, typeof RULE_KEY_SEPARATOR>>;
export type KilpiConstructor<TSubject extends object | null | undefined> = {
	/**
	 * Create subject guard
	 */
	guard: <TGuardedSubject extends object | null | undefined>(guard: SubjectGuard<TSubject, TGuardedSubject>) => SubjectGuard<TSubject, TGuardedSubject> & {
		/**
		 * Create rule wth guard
		 */
		create: <TResource>(check: (subject: TGuardedSubject, resource: TResource) => MaybePromise<boolean | Permission<TGuardedSubject>>) => Rule<TResource | TResource[], TSubject, TGuardedSubject>;
	};
	/**
	 * Create Rule without guard (equal to creating with trivial guard)
	 */
	create: <TResource>(check: (subject: TSubject, resource: TResource) => MaybePromise<boolean | Permission<TSubject>>) => Rule<TResource | TResource[], TSubject, TSubject>;
};
/**
 * Handler when `protect()` denies access. Either a sync or async function that runs a side effect
 * on denial (e.g. a log) or throws an error or other throwable, e.g. a redirect.
 */
export type OnDenyHandler = (options: {
	message?: string;
	rule: Rule<any, any, any>;
	subject: unknown;
}) => void | never | Promise<void> | Promise<never>;
/**
 * Kilpi core class to encapsulate ruleset, guards, subjects and more.
 */
export declare class KilpiCore<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TGuards extends Record<string, SubjectGuard<TSubject, object | null | undefined>>> {
	/**
	 * Subject fetcher
	 */
	getSubject: () => TSubject | Promise<TSubject>;
	/**
	 * Ruleset from construction
	 */
	ruleset: TRuleset;
	/**
	 * All subject guard functions from construction
	 */
	guards: TGuards;
	/**
	 * Inferring utilities. Do not use in runtime.
	 */
	$$infer: {
		subject: TSubject;
		ruleset: TRuleset;
		guards: TGuards;
	};
	/**
	 * New instance
	 */
	constructor(getSubject: () => TSubject | Promise<TSubject>, construct: (constructor: KilpiConstructor<TSubject>) => {
		guards: TGuards;
		rules: TRuleset;
	});
	/**
	 * Get permission to a rule inside the ruleset
	 */
	getPermission<TKey extends RulesetKeys<TRuleset>>(key: TKey, resource: InferRuleResource<GetRuleByKey<TRuleset, TKey>>): Promise<Permission<InferRuleGuardedSubject<GetRuleByKey<TRuleset, TKey>>>>;
	/**
	 * Get permission to a rule inside the ruleset (only return boolean)
	 */
	hasPermission<TKey extends RulesetKeys<TRuleset>>(key: TKey, resource: InferRuleResource<GetRuleByKey<TRuleset, TKey>>): Promise<boolean>;
	/**
	 * Throw if no permission, else return guarded subject
	 */
	protect<TKey extends RulesetKeys<TRuleset>>(key: TKey, resource: InferRuleResource<GetRuleByKey<TRuleset, TKey>>, onDeny?: OnDenyHandler): Promise<InferRuleGuardedSubject<GetRuleByKey<TRuleset, TKey>>>;
	/**
	 * Expose guards via `guard.[guardKey]` syntax, similar to protect but without requiring a
	 * resource. E.g., `await KilpiCore.guard.authed()`.
	 */
	get guard(): TGuards;
	/**
	 * Create protected query
	 */
	createProtectedQuery<TQuery extends (...args: any[]) => Promise<any>>(query: TQuery, protector?: (result: Awaited<ReturnType<TQuery>>, ...args: Parameters<TQuery>) => Promise<any>): TQuery & {
		/**
		 * Return null if the authorization check fails
		 */
		safe(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>> | null>;
		/**
		 * Throw if authorization check fails
		 */
		protect(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>>>;
	};
	/**
	 * Create endpoint handler
	 */
	createPostEndpoint(options: {
		secret: string;
	}): (request: Request) => Promise<Response>;
}
/**
 * Storage for a value that can be read and written.
 */
export type GetSetStorage<T> = {
	get: () => T;
	set: (value: T) => void;
};
/**
 * Server client construction options
 */
export type CreateKilpiServerClientOptions = {
	/**
	 * Customize `.protect()` behaviour by providing a global `.onDeny` function. You can also provide
	 * a storage with get and set methods. Using a per-request storage is recommended.
	 */
	onDeny?: OnDenyHandler | GetSetStorage<OnDenyHandler | undefined>;
};
/**
 * Type of server client
 */
export type KilpiServerClient<TCore extends KilpiCore<any, any, any>> = ReturnType<typeof createKilpiServerClient<TCore>>;
/**
 * Create a server client.
 */
export declare function createKilpiServerClient<TCore extends KilpiCore<any, any, any>>(core: TCore, options: CreateKilpiServerClientOptions): {
	guard: any;
	getSubject: () => any;
	getPermission: <TKey extends string>(key: TKey, resource: InferRuleResource<EnsureTypeIsRule<TKey extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey extends string | number | symbol ? any : never>>) => Promise<Permission<InferRuleGuardedSubject<EnsureTypeIsRule<TKey extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey extends string | number | symbol ? any : never>>>>;
	hasPermission: <TKey_1 extends string>(key: TKey_1, resource: InferRuleResource<EnsureTypeIsRule<TKey_1 extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey_1 extends string | number | symbol ? any : never>>) => Promise<boolean>;
	protect: <TKey_2 extends string>(key: TKey_2, resource: InferRuleResource<EnsureTypeIsRule<TKey_2 extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey_2 extends string | number | symbol ? any : never>>, onDeny?: OnDenyHandler | undefined) => Promise<InferRuleGuardedSubject<EnsureTypeIsRule<TKey_2 extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? Rest extends `${infer FirstKey}:${infer Rest}` ? FirstKey extends string | number | symbol ? any : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : Rest extends string | number | symbol ? any : never : never : TKey_2 extends string | number | symbol ? any : never>>>;
	createProtectedQuery: <TQuery extends (...args: any[]) => Promise<any>>(query: TQuery, protector?: ((result: Awaited<ReturnType<TQuery>>, ...args: Parameters<TQuery>) => Promise<any>) | undefined) => TQuery & {
		safe(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>> | null>;
		protect(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>>>;
	};
	createPostEndpoint: (options: {
		secret: string;
	}) => (request: Request) => Promise<Response>;
	onDeny: (onDenyHandler: OnDenyHandler | undefined) => void;
	core: TCore;
};

export {};
