// Generated by dts-bundle-generator v9.5.1

/**
 * Permission granted with refined subject included.
 */
export type PermissionGrant<TSubjectOut> = {
	granted: true;
	subject: TSubjectOut;
};
/**
 * Permission denied, no refined subject required.
 */
export type PermissionDeny = {
	granted: false;
	message?: string;
};
/**
 * Permission is either granted (with refined subject) or denied based on the discriminated
 * union by the `granted: boolean` key.
 */
export type Permission<TSubjectOut> = PermissionGrant<TSubjectOut> | PermissionDeny;
/**
 * A rule consists of the `getPermission` evaluator function, which when given the subject and
 * resource returns the permission to that resource. Additionally, it consists of the
 * `getNarrowedSubject` function which narrows the subject to a more specific type before
 * evaluation.
 */
export type Rule<TResource, TSubject, TSubjectNarrowed = TSubject> = {
	/**
	 * Based on subject and resource, return a permission. Runs subject narrowing within.
	 */
	getPermission: (subject: TSubject, resource: TResource) => Promise<Permission<TSubjectNarrowed>>;
	/**
	 * Returning false signals a denied permission. Subject-narrowing does not depend on the resource.
	 */
	getNarrowedSubject: (subject: TSubject) => TSubjectNarrowed | false;
};
/**
 * Rule inferral utilities
 */
export type InferRule<T> = T extends Rule<infer TResource, infer TSubject, infer TSubjectNarrowed> ? {
	resource: TResource;
	subject: TSubject;
	subjectNarrowed: TSubjectNarrowed;
} : never;
export type InferRuleResource<T> = InferRule<T>["resource"];
export type InferRuleSubjectNarrowed<T> = InferRule<T>["subjectNarrowed"];
/**
 * Object with string keys to type T with any depth.
 */
export type DeepObject<T> = {
	[key: string]: T | DeepObject<T>;
};
/**
 * Extracts all keys from an object which have a value of type Target.
 */
export type RecursiveKeysTo<Object, Target, Separator extends string = "."> = Object extends object ? {
	[Key in keyof Object]: Key extends string | number ? Object[Key] extends Target ? Key : `${Key}${Separator}${RecursiveKeysTo<Object[Key], Target, Separator>}` : never;
}[keyof Object] : never;
/**
 * Extracts all values from an object which have a key of type Target.
 */
export type RecursiveValueByKey<Object, Key extends string, Separator extends string = "."> = Object extends object ? Key extends `${infer FirstKey}${Separator}${infer Rest}` ? FirstKey extends keyof Object ? RecursiveValueByKey<Object[FirstKey], Rest, Separator> : never : Key extends keyof Object ? Object[Key] : never : never;
/**
 * Value optionally wrapped in a promise.
 */
export type MaybePromise<T> = T | Promise<T>;
declare const RULE_KEY_SEPARATOR: ":";
/**
 * Rule-set is a deep-object of rules which all share a common base subject type.
 */
export type Ruleset<TSubject> = DeepObject<Rule<any, TSubject, any>>;
/**
 * List of all keys in ruleset.
 */
export type RulesetKeys<TRuleset extends Ruleset<any>> = RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject> ? Rule<any, TSubject> : never, typeof RULE_KEY_SEPARATOR>;
/**
 * Ensure a value is a rule
 */
export type EnsureTypeIsRule<T> = T extends Rule<any, any, any> ? T : never;
/**
 * Type of a rule from a ruleset given a key.
 */
export type GetRuleByKey<TRuleset extends Ruleset<any>, TKey extends RulesetKeys<TRuleset>> = EnsureTypeIsRule<RecursiveValueByKey<TRuleset, TKey, typeof RULE_KEY_SEPARATOR>>;
export type CreatePostEndpointOptions<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>> = {
	subject: TSubject | (() => Promise<TSubject>);
	ruleset: TRuleset;
	secret: string;
};
declare function getRuleConstructors<TSubject extends object | null | undefined, TNarrowedSubject extends object | null | undefined = TSubject>(): {
	create: (check: (subject: TSubject) => MaybePromise<boolean | Permission<TSubject>>) => Rule<void, TSubject>;
	createOn: <TResource>(check: (subject: TSubject, resource: TResource) => MaybePromise<boolean | Permission<TSubject>>) => Rule<TResource | TResource[], TSubject>;
	subject: <TSubjectNarrowed>(getNarrowedSubject: (subject: TSubject) => false | TSubjectNarrowed) => {
		create(check: (subject: TSubjectNarrowed) => MaybePromise<boolean | Permission<TSubjectNarrowed>>): Rule<void, TSubject, TSubjectNarrowed>;
		/**
		 * Create a rule after subject narrowing for a specific resource.
		 */
		createOn<TResource_1>(check: (subject: TSubjectNarrowed, resource: TResource_1) => MaybePromise<boolean | Permission<TSubjectNarrowed>>): Rule<TResource_1 | TResource_1[], TSubject, TSubjectNarrowed>;
	};
};
export type RuleConstructors<TSubject extends object | null | undefined> = ReturnType<typeof getRuleConstructors<TSubject>>;
declare function createRuleset<TSubject extends object | null | undefined>(): <const TRuleset extends Ruleset<TSubject>>(rules: (Rule: RuleConstructors<TSubject>) => TRuleset) => TRuleset;
/**
 * Return type of get permission.
 */
export type GetPermissionReturn<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeys<TRuleset>> = Promise<Permission<InferRuleSubjectNarrowed<GetRuleByKey<TRuleset, TRulekey>>>>;
/**
 * Handler when `protect()` denies access. Either a sync or async function that runs a side effect
 * on denial (e.g. a log) or throws an error or other throwable, e.g. a redirect.
 */
export type OnDenyHandler = (options: {
	message?: string;
	rule: Rule<any, any, any>;
	subject: unknown;
}) => void | never | Promise<void> | Promise<never>;
/**
 * Return type of protection (when succesful).
 */
export type ProtectReturn<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>, TRulekey extends RulesetKeys<TRuleset>> = Promise<InferRuleSubjectNarrowed<GetRuleByKey<TRuleset, TRulekey>>>;
/**
 * Storage for a value that can be read and written.
 */
export type GetSetStorage<T> = {
	get: () => T;
	set: (value: T) => void;
};
/**
 * Server client construction options
 */
export type CreateKilpiServerClientOptions<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>> = {
	/**
	 * The subject getter function. Should be as light-weight as possible and preferrably cached
	 * per-request (e.g. in React with `React.cache`).
	 */
	getSubject: () => Promise<TSubject>;
	/**
	 * Ruleset to use. Can optionally be constructed here with a function that is given the rule
	 * constructors.
	 */
	rules: TRuleset | ((Rule: RuleConstructors<TSubject>) => TRuleset);
	/**
	 * Customize `.protect()` behaviour by providing a global `.onDeny` function. You can also provide
	 * a storage with get and set methods. Using a per-request storage is recommended.
	 */
	onDeny?: OnDenyHandler | GetSetStorage<OnDenyHandler | undefined>;
};
/**
 * Type of server client
 */
export type KilpiServerClient<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>> = ReturnType<typeof createKilpiServerClient<TSubject, TRuleset>>;
/**
 * Create a server client.
 */
export declare function createKilpiServerClient<TSubject extends object | null | undefined, TRuleset extends Ruleset<TSubject>>(options: CreateKilpiServerClientOptions<TSubject, TRuleset>): {
	getSubject: () => Promise<TSubject>;
	getPermission: {
		<TRulekey extends RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject_1> ? Rule<any, TSubject_1, TSubject_1> : never, ":">>(key: TRulekey, resource: InferRuleResource<EnsureTypeIsRule<RecursiveValueByKey<TRuleset, TRulekey, ":">>>): GetPermissionReturn<TSubject, TRuleset, TRulekey>;
		<TRulekey_1 extends RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject_1> ? Rule<any, TSubject_1, TSubject_1> : never, ":">>(key: TRulekey_1): GetPermissionReturn<TSubject, TRuleset, TRulekey_1>;
	};
	hasPermission: {
		<TRulekey_2 extends RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject_1> ? Rule<any, TSubject_1, TSubject_1> : never, ":">>(key: TRulekey_2, resource: InferRuleResource<EnsureTypeIsRule<RecursiveValueByKey<TRuleset, TRulekey_2, ":">>>): Promise<boolean>;
		<TRulekey_3 extends RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject_1> ? Rule<any, TSubject_1, TSubject_1> : never, ":">>(key: TRulekey_3): Promise<boolean>;
	};
	protect: {
		<TRulekey_4 extends RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject_1> ? Rule<any, TSubject_1, TSubject_1> : never, ":">>(key: TRulekey_4, resource: InferRuleResource<EnsureTypeIsRule<RecursiveValueByKey<TRuleset, TRulekey_4, ":">>>): ProtectReturn<TSubject, TRuleset, TRulekey_4>;
		<TRulekey_5 extends RecursiveKeysTo<TRuleset, TRuleset extends Ruleset<infer TSubject_1> ? Rule<any, TSubject_1, TSubject_1> : never, ":">>(key: TRulekey_5): ProtectReturn<TSubject, TRuleset, TRulekey_5>;
	};
	onDeny: (onDenyHandler: OnDenyHandler | undefined) => void;
	createPostEndpoint: (options: Omit<CreatePostEndpointOptions<TSubject, TRuleset>, "ruleset" | "subject">) => (request: Request) => Promise<Response>;
	createQuery: <TQuery extends (...args: any[]) => any>(query: TQuery, protector?: ((result: Awaited<ReturnType<TQuery>>, ...args: Parameters<TQuery>) => any) | undefined) => TQuery & {
		safe(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>> | null>;
		protect(...args: Parameters<TQuery>): Promise<Awaited<ReturnType<TQuery>>>;
	};
	$$types: {
		subject: TSubject;
		ruleset: TRuleset;
	};
};
declare const createRuleset$1: typeof createRuleset;

export {
	createRuleset$1 as createRuleset,
};

export {};
